# Network

1. [OSI 7계층](#osi-7계층)
   * [물리 계층 (Physical Layer)](#물리-계층-physical-layer)
   * [데이터 링크 계층 (Data Link Layer)](#데이터-링크-계층-data-link-layer)
   * [네트워크 계층 (Network Layer)](#네트워크-계층-network-layer)
   * [전송 계층 (Transport Layer)](#전송-계층-transport-layer)
   * [세션 계층 (Session Layer)](#세션-계층-session-layer)
   * [표현 계층 (Presentation Layer)](#표현-계층-presentation-layer)
   * [응용 계층 (Application Layer)](#응용-계층-application-layer)
2. [TCP/IP 모델](#tcpip-모델)
3. [TCP와 UDP](#tcp와-udp)
   * [TCP](#tcp)
   * [UDP](#udp)
   * [TCP, UDP 공통점](#tcp-udp-공통점)
   * [TCP, UDP 차이점](#tcp-udp-차이점)
   * [TCP 관련 질문](#tcp-관련-질문)
4. [HTTP와 HTTPS](#http와-https)
   * [HTTP란?](#http란)
   * [HTTPS란?](#https란)
   * [HTTP와 HTTPS](#http와-https)
5. [GET과 POST](#get과-post)
   * [GET 방식](#get-방식)
   * [POST 방식](#post-방식)
   * [GET vs POST 비교](#get-vs-post-비교)
6. [쿠키와 세션](#쿠키와 세션)
   * [쿠키](#쿠키)
   * [세션](#세션)
   * [쿠키와 세션의 차이점](#쿠키와-세션의-차이점)
7. [DNS](#dns)
   * 

## OSI 7계층

국제 표준화 기구(ISO)에서 개발한 모델으로, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것이다.

* 프로토콜을 기능별로 나눈 모델
* 각 계층은 하위 계층의 기능만을 이용하고, 상위 계층에게 기능을 제공한다.

**:heavy_plus_sign: 왜 계층을 나누게 되었을까?**

계층을 분리함으로써 각 계층은 독립적인 역할을 할 수 있다. 역할이 분리되면서 문제가 발생했을 때 현상을 보고 어떤 계층에서 문제가 생겼는지 파악 가능하다. (각 계층의 수행 역할이 다르기 때문에 가능)

<img src="https://user-images.githubusercontent.com/33208360/116966836-fd2fea80-aceb-11eb-98f6-97f590d45b53.png" alt="image" style="zoom: 67%;" />

### 물리 계층 (Physical Layer)

* 네트워크의 기본 네트워크 하드웨어 전송 기술을 이룬다.

* 전기적인, 기계적인 신호를 주고 받는 역할을 하는 계층이다.

* 이 계층에 속하는 대표적인 장비는 통신 케이블, 허브, 리피터 등이 있다.

* 데이터의 종류나 오류를 제어하지 않는다. 이는 다음 계층인 데이터 링크 계층에서 다룬다.
* 전송 단위는 Bit이다.

### 데이터 링크 계층 (Data Link Layer)

* Point to Point 간의 신뢰성있는 전송을 보장하기 위한 계층이다. 전송 데이터에 대한 CRC 오류 제어와 흐름 제어가 필요하다. (CRC: 순환 중복 검사, 여러 개의 bit 오류 수정)

* 주소 값은 물리적으로 할당받는데, 이는 네트워크 카드가 만들어질 때부터 MAC 주소가 정해져 있다는 뜻이다. 물리 주소인 MAC 주소가 이 계층에 해당한다.

* 대표적인 장비는 스위치와 브릿지가 있다.

* 데이터 링크 계층의 가장 잘 알려진 예는 *이더넷* 이다.

* 데이터 전송 단위는 Frame이다.

### 네트워크 계층 (Network Layer)

* 여러 개의 노드를 거칠 때마다 경로를 찾아주는 역할을 하는 계층으로 다양한 길이의 데이터를 네트워크들을 통해 전달하고, 그 과정에서 전송 계층이 요구하는 서비스 품질(QoS)을 제공하기 위한 기능적, 절차적 수단을 제공한다.

* 라우팅, 흐름 제어, 세그맨테이션(Segmentation/Desegmentation), 오류 제어, 인터네트워킹(InterNetworking) 등을 수행한다.
* 논리적인 주소 구조(IP), 곧 네트워크 관리자가 직접 주소를 할당하는 구조를 가지며, 계층적이다.
* 데이터 전송 단위는 Datagram(Packet)이다.

### 전송 계층 (Transport Layer)

* 양 끝단(End to end)의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.

* 시퀀스 넘버 기반의 오류 제어 방식을 사용한다.

* 전송 계층은 특정 연결의 유효성을 제어하고, 일부 프로토콜은 상태 개념이 있고(Stateful), 연결 기반(connection oriented)이다.

  (=> 전송 계층이 패킷들의 전송이 유효한지 확인하고, 전송 실패한 패킷들을 다시 전송한다는 것)

* 가장 잘 알려진 전송 계층의 예는 TCP, UDP이다.

* 데이터 전송 단위는 Segment이다.

### 세션 계층 (Session Layer)

* 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.
* 동시 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(Full Duplex)의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정 등을 수행한다.
* TCP/IP 세션을 만들고 없애는 책임을 진다.

### 표현 계층 (Presentation Layer)

* 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용계층으로부터 덜어 준다.
* MIME 인코딩이나 암호화 등의 동작이 이 계층에서 이루어진다.

### 응용 계층 (Application Layer)

* 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.
* 일반적인 응용 서비스는 관련된 응용 프로세스들 사이의 전환을 제공한다.

## TCP/IP 모델

OSI 모델은 참조 모델일 뿐 실제 사용되는 인터넷 프로토콜은 7계층 구조를 완전히 따르지는 않는다. 인터넷 프로토콜 스택은 현재 대부분 TCP/IP를 따른다.

* 인터넷 프로토콜 중 가장 중요한 역할을 하는 TCP와 IP의 합성어로, 데이터의 흐름 관리, 정확성 확인, 패킷의 목적지 보장을 담당한다.

  * 데이터의 정확성 확인은 TCP
  * 패킷을 목적지까지 전송하는 일은 IP가 담당한다.

* TCP/IP의 4계층

  <img src="https://user-images.githubusercontent.com/33208360/117919310-ba8f9300-b327-11eb-9cf3-7baec27477c3.png" alt="image" style="zoom: 50%;" />
  
  * TCP/IP는 OSI 참조 모델과 달리 Applcation 계층 하나에서 Application, Presentation, Session 계층의 구현을 다 하고 있다.
  
  * 데이터는 단계별로 헤더(Data -> Segment -> Datagram -> Frame)를 붙여 전송하며 이를 **데이터 캡슐화** 라고 한다.

</br>

## TCP와 UDP

> https://velog.io/@hidaehyunlee/TCP-%EC%99%80-UDP-%EC%9D%98-%EC%B0%A8%EC%9D%B4

TCP와 UDP는 TCP/IP의 **전송 계층**에서 사용되는 프로토콜이다. 전송계층은 IP에 의해 전달되는 패킷의 오류를 검사하고 재전송 요구 등의 제어를 담당하는 계층이다.

TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol) 두 프로토콜은 모두 패킷을 한 컴퓨터에서 다른 컴퓨터로 전달해주는 IP 프로토콜을 기반으로 구현되어 있지만, 서로 다른 특징을 가지고 있다.

* 신뢰성이 요구되는 애플리케이션에서는 TCP를 사용하고, 간단한 데이터를 빠른 속도로 전송하고자 하는 애플리케이션에서는 UDP를 사용한다.

### TCP

네트워크 계층 중 전송 계층에서 사용하는 프로토콜로서, 장치들 사이에 논리적인 접속을 성립하기 위해 연결을 설정하여 **신뢰성을 보장하는 연결형 서비스**이다. TCP는 네트워크에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 옥텟(데이터, 메세지, 세그먼트라는 블록 단위)을 **안정적으로**, **순서대로**, **에러없이** 교환할 수 있게 한다.

**1) 특징**

* 연결형 서비스

  - 가상회선 방식을 제공한다.

  - 3-way handshaking 과정을 통해 연결을 설정하고, 4-way handshaking을 통해 연결을 해제한다.

* 흐름 제어 (Flow control)

  - 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지한다.

  * 송신하는 곳에서 감당이 안되게 많은 데이터를 빠르게 보내 수신하는 곳에서 문제가 일어나는 것을 막는다.
  * 수신자가 윈도우 크기(Window Size)값을 통해 수신량을 정할 수 있다.

* 혼잡 제어 (Congestion control)

  * 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지한다.
  * 정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 막는다.

* 신뢰성이 높은 전송 (Reliable transmission)

  * Dupack-based retransmission

     : 정상적인 상황에서는 ACK 값이 연속적으로 전송되어야 한다. 그러나 ACK 값이 중복으로 올 경우 패킷 이상을 감지하고 재전송을 요청한다.

  * Timeout-based retransmission

    : 일정시간 동안 ACK 값 수신을 못할 경우 재전송을 요청한다.

* 전이중, 점대점 방식

  * 전이중 (Full-Duplex) : 전송이 양방향으로 동시에 일어날 수 있다.
  * 점대점 (Point to Point) : 각 연결이 정확히 2개의 종단점을 가지고 있다.

  => 멀티 캐스팅이나 브로드캐스팅을 지원하지 않는다.

**2) TCP Header 정보**

응용 계층으로부터 데이터를 받은 TCP는 헤더를 추가한 후에 이를 IP로 보낸다.

* 송수신자의 포트번호: TCP로 연결되는 가상 회선 양단의 송수신 프로세스에 할당되는 포트 주소
* 시퀀스 번호(Sequence Number): 송신자가 지정하는 순서 번호, 전송되는 바이트 수를 기준으로 증가.
* 응답 번호(ACK Number): 수신 프로세스가 제대로 수신한 바이트의 수를 응답하기 위해 사용.
* 데이터 오프셋(Data Offset): TCP 세그먼트의 시작 위치를 기준으로 데이터의 시작 위치를 표현(TCP헤더의 크기)

* 예약 필드(Reserved): 사용을 하지 않지만 나중을 위한 예약 필드이며 0으로 채워져야 한다.
* 제어 비트(Flag Bit): SYN, ACK, FIN등의 제어 번호
* 윈도우 크기(Window): 수신 윈도우의 버퍼 크기를 지정할 때 사용. 0아면 송신 프로세스의 전송 중지.
* 체크섬(Checksum): TCP 세그먼트에 포함되는 프로토콜 헤더와 데이터에 대한 오류 검출 용도
* 긴급 위치(Urgent Pointer): 긴급 데이터를 처리하기 위함. URG 플래그 비트가 지정된 경우에만 유효

:heavy_plus_sign: 제어 비트(Flag Bit) 정보

	* URG: 긴급 위치 필드가 유효한지 설정
 * ACK: 응답 번호 필드가 유효한지 설정. 클라이언트가 보낸 최초의 SYN 패킷 이후에 전송되는 모든 패킷은 이 플래그가 설정되어야 한다. 
   	* ACK은 송신측에 대하여 **수신측에서 긍정 응답**으로 보내지는 전송 제어용 캐릭터
   	* ACK번호를 사용하여 패킷이 도착했는지 확인한다. 송신한 패킷이 제대로 도착하지 않았으면 재송신을 요구한다.
* PSH: 수신 애플리케이션에 버퍼링된 데이터를 상위 계층에 즉시 전달할 때
* RST: 연결의 리셋이나 유효하지 않은 세그먼트에 대한 응답용
* SYN: 연결 설정 요구. 동기화 시퀀스 번호. 양쪽이 보낸 최초의 패킷에만 이 플래그가 설정되어 있어야 한다.
* FIN: 더이상 전송할 데이터가 없을 때 연결 종료 의사 표시

**3) TCP Connection(3-way handshake)**

TCP통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정

* 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 한다.
* 즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.

1. 먼저 `open()`을 실행한 클라이언트가 `SYN`을 보내고 `SYN_SENT`상태로 대기한다.
2. 서버는 `SYN_RCVD`상태로 바꾸고 `SYN`과 응답 `ACK`를 보낸다.
3. `SYN`과 응답 `ACK`을 받은 클라이언트는 `ESTABLISHED`상태로 변경하고 서버에게 응답 `ACK`를 보낸다
4. 응답 `ACK`를 받은 서버는 `ESTABLISHED`상태로 변경한다.

**4) TCP Disconnection (4-way handshake)**

TCP의 연결을 해제하는 과정

1. 먼저 `close()`를 실행한 클라이언트가 `FIN`을 보내고 `FIN_WAIT1`상태로 대기한다.
2. 서버는 `CLOSE_WAIT`으로 바꾸고 응답 `ACK`을 전달한다. 동시에 해당 포트에 연결되어 있는 애플리케이션에 `close()`를 요청한다.
3. `ACK`을 받은 클라이언트는 상태를 `FIN_WAIT2`로 변경한다.
4. `close()`요청을 받은 서버 애플리케이션은 종료 프로세스를 진행하고 `FIN`을 클라이언트에 보내 `LAST_ACK`상태로 바꾼다.
5. `FIN`을 받은 클라이언트는 `ACK`을 서버에 다시 전송하고 `TIME_WAIT`으로 상태를 바꾼다. `TIME_WAIT`에서 일정 시간이 지나면 `CLOSED`된다. `ACK`을 받은 서버도 포트를 `CLOSED`로 닫는다.

:heavy_plus_sign: 누가 먼저 `close()`를 요청하느냐에 따라 상태가 달라질 수 있다. 서버가 먼저 종료하겠다고 `FIN`을 보낼 수 있고, 이런 경우 서버가 `FIN_WAIT1`상태가 된다.

<img src="https://user-images.githubusercontent.com/33208360/117923457-0134bb80-b32f-11eb-9bce-c3214ca9f7ad.png" alt="image" style="zoom:50%;" />

### UDP

**UDP Header 정보**

응용계층으로부터 데이터를 받은 UDP도 UDP 헤더를 추가한 후에 이를 IP로 보낸다.

* 송신자의 포트 번호: 데이터를 보내는 애플리케이션의 포트 번호
* 수신자의 포트 번호: 데이터를 받는 애플리케이션의 포트 번호
* 데이터의 길이: UDP헤더와 데이터의 총 길이
* 체크섬(Checksum): 데이터 오류 검사에 사용

TCP헤더와 다르게 UDP헤더에는 포함된 정보가 부실한 느낌마저 든다. UDP는 수신자가 데이터를 받는지 마는지 관심이 없기 때문이다. 즉, 신뢰성을 보장해주지는 않지만 간단하고 속도가 빠른 것이 특징이다.

### TCP, UDP 공통점

* 포트 번호를 이용하여 주소를 지정한다.
* 데이터 오류 검사를 위한 Checksum이 존재한다.

### TCP, UDP 차이점

* TCP는 연결형 프로토콜로 연결이 성공해야 통신이 가능하다. UDP는 비연결형 프로토콜로 연결 없이 통신이 가능하다.
* TCP는 데이터의 경계를 구분하지 않는다(Byte-Stream Service). UDP는 데이터의 경계를 구분한다(Datagram Service).
* TCP는 신뢰성있는 데이터 전송(데이터의 재전송 존재)을, UDP는 비신뢰성있는 데이터 전송(데이터의 재전송 없음)을 한다.
* TCP는 일대일(Unicast)통신을, UDP는 일대일, 일대다(Broadcast), 다대다(Multicast) 통신을 한다.

### TCP 관련 질문

1. TCP의 연결 설정 과정(3단계)과 연결 종료 과정(4단계)이 단계가 차이나는 이유?

   Client가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 `FIN`에 대한 `ACK`만 보내고, 데이터를 모두 전송한 후에 자신도 `FIN`메시지를 보내기 때문이다.

2. 만약 Server에서 `FIN`플래그를 전송하기 전에 전송한 패킷이 Rounting 지연이나 패킷 유실로 인한 재전송 등으로 인해 `FIN`패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?

   이러한 현상에 대비하여 Client는 Server로부터 `FIN`플래그를 수신하더라도 일정 시간동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다. (TIME_WAIT 과정)

3. 초기 Sequence Number인 `ISN`을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유?

   Connection을 맺을 때 사용하는 포트는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. 서버 측에서는 패킷의 `SYN`을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 Number가 전송된다면 이전의 Connection으로부터 오는 패킷으로 인식할 수 있다. 이런 문제가 발생할 가능성을 줄이기 위해 난수로 `ISN`을 설정한다.

</br>

## HTTP와 HTTPS

> https://mangkyu.tistory.com/98

### HTTP란?

HTTP(Hyper Text Tranfer Protocol)란, **서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜**이다.

즉, HTTP는 인터넷에서 하이퍼텍스트를 교호나하기 위한 통신 규약으로, 80번 포트를 사용하고 있다. 따라서, HTTP 서버가 80번 포트에서 요청을 기다리고 있으며, 클라이언트는 80번 포트로 요청을 보내게 된다.

**구조**

애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동한다. HTTP는 상태를 가지고 있지 않는 Stateless 프로토콜이며 Method, Path, Version, Headers, Body 등으로 구성된다.

<img src="https://user-images.githubusercontent.com/33208360/117928142-1a8d3600-b336-11eb-8f83-3b0116f21713.png" alt="image" style="zoom: 50%;" />

하지만, HTTP는 암호화가 되지 않은 평문 데이터를 전송하는 프로토콜이었기 때문에, HTTP로 비밀번호나 주민등록번호 등을 주고 받으면 제 3자가 정보를 조회할 수 있었다. 이러한 문제를 해결하기 위해 HTTPS가 등장하게 되었다.

**:heavy_plus_sign: HTTP의 문제점**

* HTTP는 평문 통신이기 때문에 도청이 가능하다.
* 통신 상대를 확인하지 않기 때문에 위장이 가능하다.
* 완전성을 증명할 수 없기 때문에 변조가 가능하다.

### HTTPS란?

HyperText Transfer Protocol over Secure Socket Layer, HTTP over TLS, HTTP over SSL, HTTP Secure 등으로 불리는 HTTPS는 **HTTP에 데이터 암호화가 추가된 프로토콜**이다. HTTPS는 HTTP와 다르게 433번 포트를 사용하며, 네트워크 상에서 중간에 제 3자가 정보를 볼 수 없도록 공개키 암호화를 지원하고 있다.

**공개키/개인키**

HTTPS는 공개키/개인키 암호화 방식을 이용해 데이터를 암호화하고 있다. 공개키와 개인키는 서로를 위한 한쌍의 키이다.

(공개키: 모두에게 공개 가능한 키/ 개인키: 나만 가지고 알고 있어야하는 키)

* 공개키 암호화: 공개키로 암호화하면 개인키로만 복호화할 수 있다.

  -> 개인키는 나만 가지고 있으므로, 나만 볼 수 있다.

* 개인키 암호화: 개인키로 암호화하면 공개키로만 복호화할 수 있다. 

  -> 공개키는 모두에게 공개되어 있으므로, 내가 인증한 정보임을 알려 신뢰성을 보장할 수 있다.

**HTTPS의 동작 과정**

HTTPS는 SSL과 같은 프로토콜을 사용하여 공개키/개인키 기반으로 데이터를 암호화하고 있다. 데이터는 암호화되어 전송되기 때문에 임의의 사용자가 데이터를 조회하여도 원본의 데이터를 보는 것은 불가능하다.

서버는 클라이언트가 요청을 보낼대 암호화를 하기 위한 공개키를 생성해야 하는데, 일반적으로는 인증된 기관(Certificate Authority)에 공개키를 전송하여 인증서를 발급받고 있다.

### HTTP와 HTTPS

HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 안전하게 데이터를 주고받을 수 있다.

하지만 HTTPS를 이용하면 암호화/복호화의 과정이 필요하기 때문에 HTTP보다 속도가 느리다. (오늘날에는 거의 차이를 못느낄 정도) 또한, HTTPS는 인증서를 발급하고 유지하기 위한 추가 비용이 발생한다.

* 개인정보와 같은 민감한 데이터를 주고 받아야한다면 HTTPS를 이용해야 하지만, 단순한 정보 조회 등만을 처리하고 있다면 HTTP를 이용하면 된다.

</br>

## GET과 POST

> https://mangkyu.tistory.com/17

사용자가 어떤 홈페이지로 이동하기 위해서 URL을 브라우저 주소창에 작성하고 엔터를 누르면 원하는 페이지로 이동하게 된다. 사용자는 단순히 URL을 입력했을 뿐이지만 서버 내부에서는 클라이언트의 요청에 응답(웹페이지로 표현)하기 위해서 처리를 해주어야 한다. 여기서 **클라이언트가 서버로 요청을 보내는 방법**인 HTTP Method에는 크게 2가지 방식이 있는데, 바로 **GET방식과 POST방식**이다.

### GET 방식

어떠한 정보를 가져와서 조회하기 위해서 사용되는 방식이다.

**[특징]**

* URL에 변수(데이터)를 포함시켜 요청한다.
* 데이터를 Header에 포함하여 전송한다.
* URL에 데이터가 노출되어 보안에 취약하다.
* 캐싱할 수 있다.

GET방식은 간단한 데이터를 URL에 넣도록 설계된 방식으로 데이터를 보내는 양에 한계가 있다. HTTP 자체는 GET 방식의 URL 길이에 제약을 두고 있지는 않지만, 브라우저에서 최대 길이를 제한하고 있으며 URL 형식에 맞지 않는 파라미터 이름이나 값은 인코딩되어 전달해야 한다. 

(특별히 전송하는 데이터가 없으므로 GET방식에서 바디는 보통 빈 상태로 전송이 되며, 헤더의 내용 중 Body의 데이터를 설명하는 Content-type 헤더 필드도 들어가지 않는다.)

**예)** `www.mangkyu.com/login?id=mang&pw=kyu`

* `?`를 통해 URL의 끝을 알린다.
* `id`라는 key에 대해서는 `mang`이라는 value를, `pw`라는 key에 대해서는 `kyu`라는 value를 전송하는 예시. 여러개의 key와 value를 보내는 경우 `&`를 사용하여 이어준다.
* 최소한의 보안 유지도 하지 않기 때문에 실제 웹사이트에서 중요한 정보를 GET방식으로 사용하면 개인정보가 노출되는 문제가 발생한다. 
* GET방식을 사용해서 데이터를 노출시키는 경우는 개인정보가 포함되지 않는 상황에서 캐싱을 하여 속도를 높이거나 즐겨찾기를 편리하게 하기 위해 사용되는 경우가 많다.

### **POST 방식**

데이터를 서버로 제출하여 추가 또는 수정하기 위해서 사용하는 방식이다.

**[특징]**

* URL에 변수(데이터)를 노출하지 않고 요청한다.
* 데이터를 Body에 포함시킨다.
* URL에 데이터가 노출되지 않아서 기본 보안은 되어있다.
* 캐싱할 수 없다.

GET방식은 URL에 데이터를 붙여서 전송하는 반면에 POST방식은 Body에 데이터를 넣어서 전송한ㄴ다. 따라서, 헤더 필드 중 Body의 데이터를 설명하는 Content-Type이라는 헤더 필드가 들어가고 어떠한 데이터 타입인지를 명시해주어야 한다.

데이터를 Body에 포함시키는 이점 때문에 메세지 길이의 제한은 없지만 최대 요청을 받는 시간인 Time Out이 존재하므로 클라이언트에서 페이지를 요청하고 기다리는 시간이 존재한다.

실제로 POST방식은 URL에 데이터가 노출되지 않으므로 즐겨찾기나 캐싱이 불가능하지만 쿼리스트링 데이터 뿐만 아니라, 라디오 버튼, 텍스트 박스와 같은 객체들의 값도 전송 가능하다.

### GET vs POST 비교

|        처리방식        | GET 방식     | POST 방식  |
| :--------------------: | ------------ | :--------: |
| URL에 데이터 노출 여부 | O            |     X      |
|     데이터의 위치      | Header(헤더) | Body(바디) |
|     캐싱 가능 여부     | O            |     X      |

</br>

## 쿠키와 세션

> https://devuna.tistory.com/23

HTTP는 인터넷상에서 데이터를 주고 받기 위해 서버/클라이언트 모델을 따르는 통신 규약이다. 이 HTTP 프로토콜에는 **비연결성과 비상태성**이라는 특징이 있다. 이는 서버의 자원을 절약하기 위해 모든 사용자의 요청 마다 연결과 해제의 과정을 거치기 떄문에 연결상태가 유지되지 않고, 연결 해제 후에 상태정보가 저장되지 않는다는 것이다.

=> 이로 인해 사용자를 식별할 수 없어서 같은 사용자가 요청을 여러번 하더라도 매번 새로운 사용자로 인식하는 단점이 있다.

=> **이렇게 HTTP의 비연결성과 비상태성을 보완하여 서버가 클라이언트를 식별하게 해주는 것이 쿠키와 세션이다.** (사용하고 있는 웹사이트를 생각해보면 로그인을 한 번 하고 나면 그 사이트에서는 다시 로그인할 필요 없이 여러 페이지의 기능들을 이용할 수 있고, 심지어 브라우저를 종료했다가 나중에 다시 접속했을 때도 그 로그인 상태를 유지할 수 있다.)

### 쿠키

웹사이트에 접속할 때 생성되는 정보를 담은 임시 파일, 즉 서버가 사용자의 웹 브라우저에 저장하는 데이터를 말한다. 쿠키의 데이터 형태는 Key와 Value로 구성되고 String형태로 이루어져 있다.

쿠키는 서버를 대신해서 이러한 정보들을 웹 브라우저에 저장(정확히는 웹 브라우저를 이용하고 있는 컴퓨터에 저장)하고 사용자가 요청할 때 그 정보를 함께 보내서 서버가 사용자를 식별할 수 있게 해준다.

**사용 목적**

1. 세션 관리(Session Menagement)

   로그인, 사용자 닉네임, 접속 시간, 장바구니 등의 서버가 알아야 할 정보들을 저장한다.

2. 개인화(Personalization)

   사용자마다 다르게 그 사람에 적절한 페이지를 보여줄 수 있다.

3. 트래킹(Tracking)

   사용자의 행동과 패턴을 분석하고 기록한다.

**사용 예시**

쿠키가 있기 때문에 여러 페이지를 이동할 때마다 로그인을 하지 않고 사용자 정보를 유지할 수 있는 것이다. 쿠키가 없다면 'ID 저장', '로그인 상태 유지', '일주일간 다시 보지 않기', '최근 검색한 상품들을 광고에서 추천', '쇼핑몰 장바구니 기능' 등의 정보를 파라미터로 넘겨줘야 한다.

<img src="https://user-images.githubusercontent.com/33208360/117935551-cc306500-b33e-11eb-88d5-e5bd1e407dec.png" alt="image" style="zoom:50%;" />

1. 서버에서는 사용자로부터 요청이 있을 때 사용자를 구분하기 위한 임시 쿠키 하나를 보내 저장하도록 한다.

2. 저장된 쿠키는 웹 브라우저의 쿠키 저장소에 저장된다.

3. 이후 같은 사이트의 서버를 방문할 때마다, 저장된 쿠키를 요청할 header에 담아 함께 다시 서버로 전송한다.

   서버는 전송받은 쿠키와 서버에 저장된 사용자 정보를 비교하여 같은 사용자임을 확인한다.

**단점**

1. 방문했던 웹사이트에 대한 정보 및 개인정보가 기록되기 때문에 사생활을 침해할 소지가 있으며, 이를 해소하기 위해서 웹브라우저 자체에 쿠키 거부 기능이 있다. 이러한 쿠키에 대한 거부가 웹 브라우저에 설정되어 있으면 쿠키 본래의 목적인 웹브라우저와의 연결을 지속시키는 기능을 수행할 수 없는 경우가 발생한다.
2. 서버가 가지고 있는 것이 아니라 사용자에게 저장되기 때문에, 임의로 고치거나 지울 수 있고, 가로채기 쉬워 보안이 취약하다. 따라서, 쿠키에 민감하거나 중요한 정보를 담는 것은 위험하다.

=> 이러한 단점을 보완해주는 것이 세션이다.

### 세션

세션 아이디는 웹브라우저 당 1개씩 생성되어 웹 컨테이너에 저장되며 브라우저 종료 시 소멸된다. 로그인한 사용자에 대해서만 세션을 생성하는 것이 아니라 로그아웃하면 새로운 사용자로 인식해서 새로운 세션이 생성된다. (쿠키는 웹브라우저에 저장된 것이기 때문에 로그아웃 유무와 관계없이 삭제하지 않으면 유지된다.)

아이디, 닉네임 등의 정보를 세션에 담아두면 요청이 있을 때 마다, DB에 접근할 필요가 없어 효율적이다. 

### 쿠키와 세션의 차이점

1. 저장위치
   * 쿠키: 클라이언트의 웹 브라우저가 지정하는 메모리 또는 하드디스크에 저장
   * 세션: 서버의 메모리에 저장
2. 저장 형식
   * 쿠키: text형식으로 저장
   * 서버: Object형식으로 저장
3. 리소스(사용되는 자원)
   * 쿠키: 클라이언트에 저장되고 클라이언트의 메모리를 사용하기 때문에 서버의 자원을 사용하지 않음
   * 세션: 세션은 서버에 저장되고 서버의 메모리로 로딩이 되기 때문에 세션이 생길 때마다 서버의 리소스를 차지
4. 용량 제한
   * 쿠키: 클라이언트도 모르게 접속되는 사이트에 의하여 설정될 수 있기 때문에 쿠키로 인해 문제가 발생하는 것을 막고자 한 도메인당 20개, 하나의 쿠키당 4KB로 제한
   * 세션: 갯수나 용량에 제한이 없음
5. 만료 시점
   * 쿠키: 저장할 때 expires 속성을 정의해 무효화 시키면 삭제될 날짜를 지정할 수 있다. 따로 지정하지 않은 경우에는 브라우저 종료시 만료된다.
   * 세션: 클라이언트가 로그아웃하거나, 설정한 시간동안 반응이 없을 경우 무효화되기 때문에 정확한 시점을 알 수 없다.

**:heavy_plus_sign:정리**

* 쿠키는 사용자의 편의를 위한 것이며, 지워져도 되고 가로채이더라도 상관없는 수준의 정보들을 브라우저에 저장한다.
* 세션은 서버 안에서 다뤄지는 것이며, 사용자나 다른 누군가에게 노출되면 안되는 정보들은 세션으로 서비스 제공자가 직접 관리한다. 많으면 서버에 부담이 될 수 있다.

</br>

