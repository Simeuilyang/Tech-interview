# 최단 경로 알고리즘
주어진 그래프에서 두 정점을 연결하는 가장 짧은 경로의 길이를 찾는 문제

가중치 그래프(Weighted Graph)에서 간선(Edge)의 가중치 합이 최소가 되도록 하는 경로를 찾는 것이 목적

### 종류

1. 단일 출발 및 단일 도착(single-source and single-destination shortest path problem) 최단경로 문제

    그래프 내의 특정 노드 u에서 출발, 또 다른 특정 노드 v에 도착하는 가장 짧은 경로를 찾는 문제

2. 단일출발(single source shortest path) 최단 경로 문제

    그래프 내의 특정 노드 u와 그래프 내 다른 모든 노드 각각의 가장 짧은 경로를 찾는 문제

    Dijkstra algorithm

3. 전체쌍(all pair shortest path) 최단 경로 문제

    그래프 내의 모든 노드 쌍(u, v)에 대한 최단 경로를 찾는 문제 

    Floyd-warshall algorithm

### 대표적인 최단 경로 알고리즘

- 다익스트라 알고리즘 (default)
- 벨만포드 알고리즘(distance 값이 음수가 존재할 때)
- 플로이드 알고리즘(모든 시작점에 대해, 소스코드 간단)


## 다익스트라 알고리즘

다이나믹 프로그램을 이용한 최단 경로 찾기 알고리즘

- 특정 하나의 정점에서 다른 모든 정점으로 가는 최단경로를 알려준다.
- 음의 간선 있을 경우 사용 불가
- 방향 그래프
- 탐욕 알고리즘, 매 순간 최단 거리 정점을 선택한다.

### 로직

- 첫 정점을 기준으로 연결되어 있는 정점들을 추가해 가며, 최단거리를 갱신하는 기법
- BFS와 유사
    - 첫 정점부터 각 노드 간의 거리를 저장하는 배열을 만든 후, 첫 정점의 인접 노드 간의 거리부터 먼저 계산하면서, 첫 정점부터 해당 노드 간의 가장 짧은 거리를 해당 배열에 업데이트

### 순서

    distance[a][c] > distance[a][b] + distance[b][c]가 성립한다면
    distance[a][c] = distance[a][b] + distance[b][c];

즉, a와 c사이에 경로를 한번에 가는 것 보다 b를 우회하는 경로가 더 효율적인 경우 대체 하겠다.

1. 출발 노드 설정
2. 출발 노드를 기준으로 각 노드의 최소 비용 저장
3. 방문하지 않은 노드 중에서 가장 비용이 적게 드는 노드 선택
4. 해당 노드를 거쳐 특정한 노드로 가는 경우를 고려하여 최소 비용 갱신
5. 3번과 4번 과정 반복

### 구현

- 집합으로 푸는 방식
    - 집합으로 푸는 방식은 위의 공식 하나로 끝
- 우선순위 큐(Heap)을 쓰는 방식
    - 기존의 우선순위 큐에 있는 것 보다 짧은 경로가 큐에 들어올 경우 2가지 방법
        - 기존의 존재하고 있는 경로를 찾아내 짧은 경로로 변경한다.
        - 기존의 경로를 그대로 두고 짧은 경로를 추가한다. 그리고 큐에서 처리할 때 먼저 들어온 경로를 무시한다.
    - Min Heap사용

        현재 가장 짧은 거리를 가진 노드 정보를 먼저 꺼냄

        1. 첫 정점을 기준으로 배열을 선언하여 첫 정점에서 각 정점 까지의 거리를 저장
            - 초기에는 첫 정점의 거리는 0, 나머지는 무한대(inf)
            - 우선순위 큐에 [첫정점, 거리0] 만 먼저 넣음
        2. 우선 순위 큐에서 노드 꺼냄
            - 처음에는 첫 정점만 저장되어 있기 때문에 첫 정점이 꺼내진다.
            - 첫 정점에 인접한 노드들 각각에 대해, 첫 정점에서 각 노드로 가는 거리와 현재 배열에 저장되어 있는 첫 정점에서 각 정점 까지의 거리를 비교한다.
            - 배열에 저장되어 있는 거리보다, 첫 정점에서 해당 노드로 가는 거리가 더 짧을 경우 배열에 해당 노드의 거리를 업데이트 한다.
            - 배열에 해당 노드의 거리가 업데이트 된 경우, 우선순위 큐에 넣는다.
                - 결과적으로 너비 우선 탐색 방식과 유사, 첫 정점에 인접한 노드들을 순차적으로 방문
                - 만약 배열에 기록된 현재까지 발견된 가장 짧은 거리보다, 더 긴거리(루트)를 가진 [노드, 거리]의 경우에는 해당 노드와 인접한 노드 간의 거리 계산을 하지 않음(큐에 넣지 않음)
        3. 2번의 과정을 우선순위 큐에 꺼낼 노드가 없을 때까지 반복한다.

### 시간복잡도

- 집합으로 푸는 방법(선형 탐색 방법)

    O(N^2)

- 힙 사용시

    O(|E|+|E|log|E|) = O(|E|log|E|)

    - 모든 간선들을 검사하는데 드는 시간 E
    - 우선순위 큐에 원소를 추가하거나 삭제하는데 걸리는 시간 ElogE
        - 최악의 경우는 모든 간선이 검사될 때마다, 배열의 최단 거리가 갱신되고 우선순위 큐에 노드/거리가 추가되는 것, 이 때 추가는 각 간선마다 최대 한 번 일어날 수 있으므로 최대 O(E)의 시간이 걸리고, O(E)개의 노드/거리 정보에 대해 우선순위 큐를 유지하는 작업은 O(logE)가 걸림
        - 따라서 O(ElogE)

### 음수 간선이 불가능한 이유

- 그래프 내 음수 사이클이 존재하게 되면 다익스트라가 동작되면서 무한히 음수 사이클을 돌면서 거리가 작아질 수 있다.
    - 다익스트라에서는 같은 간선을 재 이용하는 것을 고려하지 않기 때문에 이 상황에서 최단 경로를 구할 수 없다.
- 음수 간선을 이용할 경우, 다익스트라의 시간 복잡도가 유지되지 않는다.
    - 최단 경로가 보장되지 않는 남아있는 정점들 중, `최소 거리를 갖는 정점은 최단 경로이다` 가 보장되지 않으면서 발생
    - 최단 경로임이 보장되지 않는 정점에서, 음수 간선을 타고 다른 정점으로 이동한 경로가 현재 남아있는 정점들 중 최소거리보다 더 작아질 수 있기 때문

    ![Untitled](https://user-images.githubusercontent.com/33089715/116966441-29973700-aceb-11eb-9805-d22b5feab172.png)


    + 0에서 1, 2로가는 최단거리 업데이트 후, 다음 노드는 2를 선택하게 된다. 그렇다면 2는 확정이기 때문에 더이상 업데이트 될 수 없다.

## 벨만 포드 알고리즘

벨만 포드 알고리즘은 음의 가중치를 갖는 방향 그래프에서 SSSP를 찾는 것이 목적

+ 간선이 음의 가중치를 갖는 경우, 그리고 그 간선이 순환 구조를 띄는 경우에는 최단 경로를 구할 수 없다.

+ 거리가 짧아지는 경우가 생긴다면 계속 업데이트를 해주는 방식

+ V(정점)*E(간선) 번 반복 후 종료 된다.(정점의 개수 만큼 모든 간선을 Relax) 

+ 다익스트라 알고리즘과 마찬가지로 시작점 부터 모든 정점으로의 최단 경로를 구하는데 다익스트라 알고리즘 보다는 시간이 오래걸리지만 간선 cost 가 음수일 때도 사용할 수 있다.
![image](https://user-images.githubusercontent.com/33089715/116966607-8e529180-aceb-11eb-987c-f623559c0f2e.png)
    + 위의 예시에서 벨만포드는 0에서 1, 0에서 2를 업데이트 하고, 또 1에서 2까지도 확인 한다. 따라서 음수 가중치 가능, but 음수 사이클은 불가능 

### 전제조건

1. 최단 경로는 사이클을 포함할 수 없기 때문에, 최대 |V|-1 개의 간선만 사용할 수 있다.

    즉 3개의 노드가 있을 때, 2개 까지 간선만 허용한다는 의미

2. 최단 거리가 업데이트 되는 노드가 없어질 때 까지 계속해서 반복하여 구해주고 음의 가중치로 인해 업데이트를 무한히 하게 되는 경우 탈출 시켜주어야 한다.

### 시간복잡도, 공간복잡도

+ 매 라운드마다 모든 에지를 점검해야 하고, 총 라운드의 수는 |V|-1 이므로 O(|V||E|). |E| 는 최대 |V|^2 따라서 O(|V|^3)
+ 각 노드마다 매 순간 최단 거리를 저장해야 하므로 공간 복잡도는 O(|V|)

### 수도코드
![Untitled](https://user-images.githubusercontent.com/33089715/116966597-885cb080-aceb-11eb-912f-d21d55586e11.png)

1) line 1

    그래프 초기화, 처음 시작할 정점 제외 무한대로 설정하고, 처음 시작할 정점을 0 으로 할당

2) line 2~4

    정점의 개수 만큼 반복문을 돌면서 모든 간선에 대해 Relax 를 수행한다.

3) line 5~8

    음의 가중치를 갖는 순환 경로가 존재하는지 확인한다.(한번 더 확인하고 업데이트가 생기면 사이클이 있다고 판단.) 

    존재 한다면 false 를 반환하고 존재하지 않으면 벨만 포드 알고리즘이 잘 작동했다는 true 를 반환


## 플로이드 와샬 알고리즘(Floyd Warshall)

+ 다익스트라 알고리즘이 하나의 정점에서 다른 모든 정점으로의 최단거리를 구하는 알고리즘이라면, 
**플로이드 와샬 알고리즘은 모든 정점에서 모든 정점으로의 최단 거리를 구하는 알고리즘이다.**

+ 다익스트라 알고리즘이 가장 적은 비용을 하나 씩 선택해야 했다면, 플로이드 와샬 알고리즘은 **`거쳐가는 정점`** 을 기준으로 알고리즘을 수행한다.

### 순서

- 두 정점 사이에 간선이 존재하지 않는다면 dist 배열에 INF를 설정
- 만약 간선이 존재한다면 가중치를 설정
- `i → j` 의최단 경로는 k를 지나는 경우와 지나지 않는 경우 중 하나이다.
    - 정점 i와 j의 경우를 탐색할 때, k는 모든 정점을 반복문으로 탐색
    - `i → j` 의 비용과 `i → k + k → j` 의 비용 중 최소 값을 저장

### 예시
<img width="300" alt="2" src="https://user-images.githubusercontent.com/33089715/116966987-51d36580-acec-11eb-8711-deb908cc4470.png">

1. 2차원 배열을 만들고 그래프의 간선의 정보 저장

    <img width="300" alt="2" src="https://user-images.githubusercontent.com/33089715/116966985-50a23880-acec-11eb-91d9-f4d65eabf5f1.png">

2. 경유지 1 - 그래프 상에서 1을 지나는 경로가 없기 때문에 초기 상태와 동일

    <img width="300" alt="3" src="https://user-images.githubusercontent.com/33089715/116966978-4e3fde80-acec-11eb-87fb-e841fa6a34bd.png">

3. 경유지 2 - 그래프 상에서 2를 지나는 경로 (1→2→4)가 (1→4) 의 경로보다 더 짧기 때문에 그래프 상에서 (1,4) 부분이 업데이트 된 것을 볼 수 있다.

    <img width="300" alt="4" src="https://user-images.githubusercontent.com/33089715/116966974-4c761b00-acec-11eb-9d94-0ade8c807c62.png">

3. 경유지 4까지 모두 지난 상태

    <img width="300" alt="5" src="https://user-images.githubusercontent.com/33089715/116966960-46803a00-acec-11eb-83f7-5d5de4da4b7a.png">


### 구현

```java
for(int k=0;k<graph.length; k++)
	for(int u = 0;u<graph.length;u++)
		for(int w = 0;w<graph.length;w++)
			if(distance[u][w]<distance[u][k]+distance[k][w])
					distance[u][w] = distance[u][k]+distance[k][w];
```

### 시간 복잡도

O(N^3)

---
### 출처

[https://noil0816.tistory.com/43](https://noil0816.tistory.com/43)