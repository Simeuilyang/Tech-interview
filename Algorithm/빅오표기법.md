# 빅오 표기법

**빅오 표기법(big-o notation)은 알고리즘의 효율성을 표기해주는 표기법이다.**

알고리즘의 효율성은 데이터 개수 n이 주어졌을 때 덧셈, 뺄셈, 곱셈과 같은 기본 연산의 횟수를 의미한다.

빅오 표기법은 보통 알고리즘의 시간 복잡도와 공간 복잡도를 나타내는데 주로 사용된다.

(시간 복잡도는 알고리즘의 시간 효율성을 의미하고, 공간 복잡도는 알고리즘의 공간(메모리) 효율성을 의미한다.)

## 빅 오
빅오 표기법은 알고리즘 효율성을 **상한선** 기준으로 표기한다.(최대치, 최악의 경우)
![image](https://user-images.githubusercontent.com/33089715/116871149-c22ba980-ac4e-11eb-81fe-085227a901ec.png)

### 빅오 표기법이 가장 널리 사용되는 이유?
+ 알고리즘의 평균적인 시간은 의미가 없는 경우가 많다. 극단적인 경우 O(n)인 함수가 상황에 따라 O(2^n)으로 치솟는 경우가 있을 수도 있다. 따라서 "절대로 이 시간은 넘지 않을거야", 라고 말하는 것이 가장 신뢰도가 높다.

### 특징
1. 상수항 무시 : 빅오 표기법은 데이터 입력값(n)이 충분히 크다고 가정하고 있고, 알고리즘의 효율성 또한 데이터 입력값(n)의 크기에 따라 영향 받기 때문에 상수항 같은 사소한 부분은 무시한다.
    + ex) O(2n) → O(n)
2. 영향력 없는 항 무시 : 빅오 표기법은 데이터 입력 값(n)의 크기에 따라 영향을 받기 때문에 가장 영향력이 없는 항들은 무시한다.
    + ex) O(n^2+2n+1) → O(n^2) 와 같이 영향력이 가장 큰 n^2 외에는 다 무시

### 종류
![image](https://user-images.githubusercontent.com/33089715/116871523-5ac22980-ac4f-11eb-8c09-cf3339ca2626.png)

알고리즘의 성능은 `O(1)` > `O(logN)` > `O(N)` > `O(NlogN)` > `O(N^2)` > ... > `O(2^N)` 순으로 나타낼 수 있다. (상수함수 > 로그함수 > 선형함수 > 다항함수 > 지수함수)

**예시**
1. O(1) : 스택에서 push, pop
2. O(log N) : 이진 트리 탐색
3. O(N) : for 문
4. O(NlogN) : 퀵 정렬(quick sort), 병합 정렬(merge sort), 힙 정렬(heap sort)
5. O(N²) : 2중 for문, 삽입 정렬(insert sort), 거품 정렬(bubble sort), 선택 정렬(selection sort)
6. O(2^N) : 피보나치 수열...

## 빅 오메가
빅 오메가는 빅 오와는 반대되는 개념으로, 최선의 경우를 나타낸다.
![image](https://user-images.githubusercontent.com/33089715/116872087-416dad00-ac50-11eb-9d9f-7992d78210a6.png)

+ 예를들어 n²+2n+1=Ω(n²), Ω(log n), Ω(n), Ω(1)이 된다.(오메가 안에 있는 함수들이 일정 숫자 이상이 되면 왼쪽의 식보다 항상 작아진다.)

## 빅 세타
빅 오와 빅 오메가의 공통부분, 최소와 최악의 중간인 평균적인 복잡도를 의미한다.
![image](https://user-images.githubusercontent.com/33089715/116872106-49c5e800-ac50-11eb-8647-ce8aa18558ff.png)

+ n²+2n+1의 경우를 예로들면, 이 함수는 O(n²)과 Ω(n²)을 동시에 만족, 그렇기 때문에 이 함수는 Θ(n²)이라고 할 수 있습니다.
    + 반면에, O(n³)같은 경우는 Ω(n³)을 만족시키지 못하고, Ω(n*log n)은 O(n*log n)을 만족시키지 못한다. 그러므로 n³은 n²+2n+1의 세타 표기법으로 표기할 수 없다.
    
---
### 출처
https://vaert.tistory.com/117
https://memostack.tistory.com/5