# Data Structure

1. [Array vs LinkedList](#array-vs-linkedlist)

   * [Array (배열)](#array-배열)
   * [LinkedList](#linkedlist)
   * [Array와 LinkedList 차이점?](#array와-linkedlist-차이점)
   * [결론](#결론)
2. [ArrayList vs LinkedList](arraylist-vs-linkedlist)

   * [ArrayList](#arraylist)
   * [LinkedList](#linkedlist)
   * [데이터 검색, 삽입, 삭제 성능 비교](#데이터-검색-삽입-삭제-성능-비교)
3. [HashTable](#hashtable)

   * [HashTable(해시테이블)이란?](#hashtable해시테이블이란)
   * [Hash값이 충돌하는 경우](#hash값이-충돌하는-경우분리연결법-개방-주소법-resizing)
   * [해시테이블의 시간 복잡도](#해시테이블의-시간-복잡도)
   * [HashTable의 장점](#hashtable의-장점)
   * [HashTable의 단점](#hashtable의-단점)
   * [Java의 HashMap과 Hashtable의 차이](#java의-hashmap과-hashtable의-차이)
4. [Stack](#stack)
5. [Queue](#queue)
6. [Graph](#graph)
   * [관련 용어](#관련-용어)
   * [특징](#특징)
   * [종류](#종류)
   * [구현 2가지](#구현-2가지)
   * [탐색](#탐색)
7. [Tree](#tree)
   * [특징](#특징)
   * [종류](#종류)
   * [구현 방법](#구현-방법)
8. [Graph vs Tree](#graph-vs-tree)
9. [Heap](#heap)
   * [종류](#종류)
   * [구현](#구현)
10. [균형 트리](#균형-트리)
    * [AVL Tree](#avl-tree)
    * [Red-Black Tree](#red-black-tree)

## Array vs LinkedList

### Array (배열)

- 논리적 저장 순서와 물리적 저장 순서가 일치한다.

- 인덱스로 해당 원소에 접근이 가능하다.

  ⇒ 인덱스만 알고 있다면 시간 복잡도 O(1)만에 해당 원소로 접근할 수 있다.

  ⇒ 즉, Random Access가 가능하다.

- 배열의 원소를 삭제할 경우, 삭제한 원소보다 큰 인덱스를 가지는 원소들을 옮겨줘야(Shift)하기 때문에 시간 복잡도 O(n)이 걸린다.

  삽입의 경우, 새로운 원소를 추가하고 모든 원소들의 인덱스를 1식 Shift 해줘야 하므로 시간 복잡도 O(n)이 걸린다.

  ⇒ 즉, 삭제 또는 삽입의 과정에서 해당 원소에 접근하여 작업을 완료한 뒤 Shift를 해줘야 하는 cost가 발생하기 때문에 O(n)의 시간복잡도를 갖는다.

- 제한적인 크기를 갖는다.

### LinkedList

- 자료의 주소 값으로 노드를 이용해 서로 연결되어 있는 구조를 갖는다.

- 삽입과 삭제의 경우, LinkedList가 Array보다 속도가 빠르다고 하지만 엄밀히 말하면 경우에 따라 다르다.

  ⇒ LinkedList 역시 삽입과 삭제를 위해서 해당 노드를 찾아가는 동안 O(n)의 시간 복잡도를 갖는다.

  ⇒ 만약, 중간 삽입이 없다면, 즉 맨 앞과 맨 뒤에 삽입한다면 시간 복잡도 O(1)

  ⇒ 삭제도 마찬가지. 중간 삭제가 없고 맨 앞과 맨 뒤에서만 삭제한다면 시간 복잡도 O(1)

- 원하는 값을 찾기 위해서 최소 한 번은 리스트를 순회해야 하므로 O(n)의 시간 복잡도를 갖는다.

- 트리의 근간이 되는 자료구조이다.

### Array와 LinkedList 차이점?

1. 데이터 접근 속도

   - Array는 인덱스를 사용해 빠르게 원소에 접근할 수 있다. Random Access를 지원한다. 시간 복잡도 O(1)로 빠르게 찾을 수 있다.
   - LinkedList는 순차 접근 방식을 사용한다. 특정 원소에 접근하기 위해서는 처음부터 원소에 도달할 때까지 순차적으로 검색하면서 찾는다. 시간 복잡도 O(N)

2. 데이터의 삽입 속도

   - Array의 경우 데이터를 중간이나 맨 앞에 삽입할 경우, 그 이후의 데이터를 한 칸 씩 미뤄야 하는 추가 과정과 시간이 소요된다. 데이터가 많을수록 비효율적이다.

     ⇒ 그렇기 때문에 LinkedList가 필요

   - LinkedList는 어느 곳에 삽입하던지 O(N)의 시간 복잡도를 갖는다. (중간 삽입이 없다면 O(1)의 시간 복잡도를 갖는다.)

     ⇒ 삽입할 위치를 찾고(O(N)), 삽입 연산을 진행하기 때문에 O(N)의 시간 복잡도를 갖는다. 그럼에도 Array보다 빠른 성능을 보인다.

   - 또, Array의 경우 데이터 삽입 시 모든 공간이 다 차버렸다면 새로운 메모리 공간을 할당 받지만, LinkedList는 그럴 필요가 없다. 추가할 때마다 동적으로 할당한다.

3. 데이터의 삭제 속도

   - Array는 데이터의 삭제의 경우 그 위치의 데이터를 삭제한 후, 전체적으로 Shift해줘야 한다. (O(N))
   - LinkedList의 경우 삭제할 원소를 찾기 위해서 O(N)의 시간 복잡도를 갖고 삭제를 한다. 결국 O(N)의 시간 복잡도를 갖는다. 하지만 Array보다 빠르게 삭제 연산을 수행한다.

4. 메모리 할당

   - Array에서 메모리는 Array가 선언되지 마자 Compile time에 할당되어 진다. 이것을 정적 메모리 할당이라고 한다.
   - LinkedList에서 메모리는 새로운 node가 추가될 때 Runtime에 할당되어진다. 이것은 동적 메모리 할당이라고 한다.

5. Size

   - Array의 size는 반드시 선언 시점에 지정되어 있어야 한다.
   - LinkedList의 size는 다양할 수 있다. node들이 추가될 때 Runtime시점에서 LinkedList의 size가 커질 수 있기 때문이다.

### 결론

- 삽입과 삭제가 빈번하다면 LinkedList를 사용하는 것이 더 좋다.
- 데이터의 접근하는 것이 중요하다면 Array를 사용하는 것이 더 좋다.

</br>

## ArrayList vs LinkedList

### ArrayList

- 내부적으로 데이터를 배열에서 관리하며, 데이터의 추가, 삭제를 위해서 임시 배열을 생성해 데이터를 복사하는 방법을 사용한다.
- 대량의 자료를 추가/삭제 하는 경우 그만큼 데이터의 복사가 많이 일어나게 되어 성능 저하가 발생한다.
- 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 존재해야 한다.
- 인덱스를 가지고 있어 한 번에 참조가 가능해 데이터 검색에 유리하다.

원소에 대해 빠르게 접근할 수 있을 뿐만 아니라, 원소들이 메모리에 연속으로 배치해 있어 CPU 캐시 효율도 더욱 높다.

### LinkedList

- 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있으면 된다.
- ArrayList와 달리 데이터의 추가/삭제 시, 불필요한 데이터의 복사가 없어 데이터의 추가, 삭제 시에 유리하다.
- 반면, 데이터 검색 시에는 처음부터 노드를 순회하기 때문에 성능상 불리하다.

### 데이터 검색, 삽입, 삭제 성능 비교

1. 검색
   - ArrayList : 인덱스 기반이기 때문에 O(1)의 시간 복잡도를 갖는다.
   - LinkedList : 검색 시 모든 요소를 순차적으로 탐색해야 하기 때문에 O(N)의 시간 복잡도를 갖는다.
2. 삽입, 삭제
   - ArrayList : 삽입, 삭제 이후 다른 데이터를 복사해야 하기 때문에 O(N)의 시간 복잡도를 갖는다. (가지고 있던 용량이 꽉 찼을 때, 용량이 기존의 1.5배를 늘린 새로운 배열에 기존 배열을 copy하는 것)
   - LinekdList : 이전 노드와 다음 노드를 참조하는 상태만 변경하면 되기 때문에 삽입, 삭제 시에 O(1)의 시간 복잡도를 갖는다.

</br>

## HashTable

### HashTable(해시테이블)이란?

(Key, Value)로 데이터를 저장하는 자료 구조

- 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문에 빠르게 데이터를 검색할 수 있는 자료 구조이다.

- 각각의 Key값에 해시 함수를 적용해 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색하게 된다.

  ⇒ 여기서 실제 값이 저장되는 장소를 버킷 또는 슬롯 이라고 한다.

- 이러한 구조로 데이터를 저장하면 Key값으로 데이터를 찾을 때, 해시 함수를 1번만 수행하면 되므로 매우 빠르게 데이터를 저장/삭제/조회 할 수 있다.

  ⇒ 해시 테이블의 평균 시간 복잡도는 O(1)이다.

**:heavy_plus_sign: Hash 함수 (해시 함수)**

해시 함수에서 가장 중요한 것은 고유한 인덱스 값을 설정하는 것이다. 대표적인 해시 함수로는 아래의 3가지가 있다.

1. Division Method

   나눗셈을 이용하는 방법으로 입력값을 테이블의 크기로 나누어 계산한다.

   (주소 = 입력값 % 테이블의 크기)

   테이블의 크기를 소수로 정하고 2의 제곱수와 먼 값을 사용해야 효과가 좋다고 알려져 있다.

2. Digit Folding

   각 Key의 문자열을 ASCII코드로 바꾸고 값을 합한 데이터를 테이블 내의 주소로 사용하는 방법이다.

3. Multiplication Method

   숫자로 된 Key값 K와 0과 1사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 다음과 같은 계산을 해준다.

   h(k) = (kAmod1)*m

4. Universal Hashing

   다수의 해시 함수를 만들어 집합 H에 넣어 두고, 무작위로 해시 함수를 선택해 해시 값을 만드는 기법이다.

### Hash값이 충돌하는 경우(분리연결법, 개방 주소법, Resizing)

해시 테이블에서는 충돌에 의한 문제를 **분리 연결법**과 **개방 주소법** 크게 2가지로 해결하고 있다.

1. **분리 연결법 (Separate Chaining)**

   동일한 버킷의 데이터에 대해 자료구조를 활용해 추가 메모리를 사용하여 다음 데이터의 주소를 저장하는 것이다.

   (⇒ 동일한 버킷으로 접근한다면, 데이터들을 연결해서 관리해준다.)

   (➕ 실제로 Java8의 Hashtable은 Self-Balancing Binary Search Tree 자료구조를 사용해 Chaning방식을 구현하였다. JDK 내부에서 사용하는 충돌 처리 방식)

   - 이러한 Chaining 방식은 해시 테이블의 확장이 필요 없고, 간단하게 구현이 가능하며, 손쉽게 삭제할 수 있다는 장점이 있다.
   - LinkedList 구조를 사용하기 때문에 추가 데이터 수 제약이 적은 편이다. 하지만, 데이터의 수가 많아지면 동일한 버킷에 Chaining되는 데이터가 많아지며 그에 따라 캐시의 효율성이 감소한다는 단점이 있다.

2. **개방 주소법 (Open Addressing)**

   추가적인 메모리를 사용하는 Chaining 방식과 다르게 비어있는 해시 테이블의 공간을 활용하는 방법이다.

   Separating Chaining 방식에 비해 적은 메모리를 사용한다.

   Open Addressing을 구현하기 위한 대표적인 방법으로는 3가지 방식이 존재한다.

   1. Linear Probing(선형 탐사)

      현재의 버킷 index로부터 고정폭만큼씩 이동하여 차례대로 검색해 비어있는 버킷에 데이터를 저장한다.

   2. Queadratic Probing(제곱 탐사)

      해시의 저장 순서 폭을 제곱으로 저장하는 방식이다.

      예를 들어, 처음 충돌이 발생한 경우에는 1만큼 이동하고, 그 다음 계속 충돌이 발생하면 2^2, 3^2 칸씩 옮기는 방식이다.

   3. Double Hashing Probing(이중 해싱)

      해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애버리는 방식이다.

      해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 하게 된다.

   Open Addressing에서 데이터를 삭제하면 삭제된 공간은 Dummy Space로 활용되는데, 그렇기 때문에 HashTable을 재정리해주는 작업이 필요하다고 한다.

3. **Resizing**

   저장 공간이 일정 수준 채워지면 Separating Chaining의 경우 성능 향상을 위해 Open Addressing의 경우 배열 크기 확장을 위해 Resizing한다.

   보통 2배로 확장하며, 확장 임계점은 현재 데이터 개수가 Hash bucket 개수의 75%가 될 때이다.

### 해시테이블의 시간 복잡도

각각의 Key값은 해시 함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로, 평균 O(1)의 시간 복잡도로 데이터를 조회할 수 있다.

하지만, 데이터의 충돌이 발생한 경우 Chaining에 연결된 리스트들까지 검색을 해야하므로 O(N)까지 시간 복잡도가 증가할 수 있다.

충돌을 방지하는 방법들은 데이터의 규칙성(클러스터링)을 방지하기 위한 방식이지만, 공간을 많이 사용한다는 치명적인 단점이 있다.

만약, 테이블이 꽉 차있는 경우라면 테이블을 확장해주어야 하는데, 이는 매우 심각한 성능 저하를 불러오기 때문에 가급적이면 확장을 하지 않도록 테이블을 설계해주어야 한다.

( ⇒ 통계적으로, 해시 테이블의 공간 사용률이 70~80% 정도가 되면 해시의 충돌이 빈번하게 발생하여 성능이 저하되기 시작한다고 한다.)

➕ 또한 해시 테이블에서 자주 사용하게 되는 데이터를 Cache에 적용하면 효율을 높일 수 있다. 자주 hit하게 되는 데이터를 캐시에서 바로 찾음으로써 해시 테이블의 성능을 향상시킬 수 있다.

### HashTable의 장점

- 적은 리소스로 많은 데이터를 효율적으로 관리 가능하다.

- 배열의 인덱스를 사용하기 때문에 빠른 검색, 삽입, 삭제 ⇒ O(1)

  (Hashtable의 경우 인덱스는 데이터의 고유 위치이기 때문에 삽입, 삭제 시 다른 데이터를 이동할 필요가 없어 삽입, 삭제도 빠른 속도로 가능하다.)

- Key와 Hash에 연관성이 없어 보안에 유리하다.

- 데이터 캐싱에 많이 사용된다.

  get, put기능에 캐시 로직 추가 시, 자주 hit하는 데이터 바로 검색 가능

- 중복 제거에 유용하다.

### HashTable 단점

- 충돌 발생 가능성
- 공간 복잡도 증가
- 순서 무시
- 해시 함수에 의존

### Java의 HashMap과 Hashtable의 차이

그 차이는 동기화 지원 여부에 있다.

해시테이블의 put에는 `synchronized` 키워드가 붙어있는데, 이것은 병렬 프로그래밍을 할 때 동기화를 지원해준다는 것을 의미한다. 이것은 해당 함수를 처리하는 시간이 조금 지연됨을 의미한다.

그렇기 때문에, 병렬 처리를 하면서 자원의 동기화를 고려해야 하는 상황이라면 `Hashtable`을 사용해야 하며, 병렬 처리를 하지 않거나 자원의 동기화를 고려하지 않는 상황이라면 `HashMap`을 사용하면 된다.

</br>

## Stack

한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out)형식의 자료 구조이다.

- 배열과 달리, 스택은 상수 시간에 i번째 항목에 접근할 수 없다.
- 하지만, 스택에서 데이터를 추가하거나 삭제하는 연산은 상수 시간에 가능하다.
- 배여러럼 원소들을 하나씩 옆으로 밀어 줄 필요가 없다.

**연산**

* pop() : 스택에서 가장 위에 있는 항목을 제거한다.

* push(item) : item 하나를 스택의 가장 윗 부분에 추가한다.

* peek() : 스택의 가장 위에 있는 항목을 반환한다.

* isEmpty() : 스택이 비어있을 때 true를 반환한다.

**구현**

연결 리스트로 구현할 수 있다. 연결 리스트의 같은 방향에서 아이템을 추가하고 삭제하도록 구현한다.

<br>

## Queue

먼저 집어 넣은 데이터가 먼저 나오는 FIFO(First In First Out) 구조로 저장하는 형식이다.

**연산**

* add(item) : item을 리스트의 끝 부분에 추가한다.

* remove() : 리스트의 첫 번째 항목을 제거한다.

* peek() : 큐에서 가장 위에 있는 항목을 반환한다.

* isEmpty() : 큐가 비어있을 때에 true를 반환한다.

**구현**

연결 리스트로 구현할 수 있다. 연결 리스트의 반대 방향에서 항목을 추가하거나 제거하도록 구현한다.

**:heavy_plus_sign: Java 라이브러리 Queue 관련 메소드**

두 가지 형태의 메소드

1. 수행이 실패했을 때 *exception* 을 발생

   `add(e)` , `element()`, `remove()`

2. 수행이 실패했을 때 *null* 또는 *false* 를 반환

   `offer(e)`, `peek()`, `poll()`

* `add(e)`, `offer(e)` : 해당 아이템을 Queue에 삽입

* `element()`, `peek()` : Queue의 Head에 있는 아이템을 삭제하지 않고 반환

* `remove()` , `poll()` : Queue의 Head에 있는 아이템을 삭제하고 반환

</br>

## Graph

단순히 노드와 그 노드를 연결하는 간선을 하나로 모아 놓은 자료구조이다. 

⇒ 즉, 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조이다.

### 관련 용어

- 정점(Vertex): 위치라는 개념. Node라고도 부른다.

- 간선(Edge): 위치 간의 관계. 즉, 노드를 연결하는 선. link, branch라고도 부른다.

- 인접 정점(Adjacent vertex): 간선에 의해 직접 연결된 정점

- 정점의 차수(degree): 무방향 그래프에서 하나의 정점에 인접한 정점의 수

  `무방향 그래프에 존재하는 정점의 모든 차수의 합 = 그래프의 간선 수의 2배`

- 진입 차수(in-degree): 방향 그래프에서 외부에서 오는 간선의 수(내차수라고도 부른다)

- 진출 차수(out-degree): 방향 그래프에서 외부로 향하는 간선의 수 (외차수라고도 부른다.)

- 경로 길이(path length): 경로를 구성하는 데에 사용된 간선의 수

- 단순 경로(simple path): 경로 중에서 반복되는 정점이 없는 경우

- 사이클(cycle): 단순 경로의 시작 정점과 종료 정점이 동일한 경우

### 특징

- 그래프는 네트워크 모델이다.

- 2개 이상의 경로가 가능하다.

  즉, 노드들 사이에 무방향/방향에서 양방향 경로를 가질 수 있다.

- self-loop 뿐 아니라 loop/circuit 모두 가능하다.

- 루트 노드라는 개념이 없다.

- 부모-자식 관계라는 개념이 없다.

- 순회는 DFS나 BFS로 이루어진다.

- 그래프는 순환(cyclic) 또는 비순환(Acyclic)이다.

- 크게 방향 그래프와 무방향 그래프가 있다.

- 간선의 유무는 그래프에 따라 다르다.

### 종류

1. 무방향 그래프 vs 방향 그래프

   - 무방향 그래프 (Undirected Graph)

     간선을 통해서 양 방향으로 갈 수 있다.

     정점 A와 정점 B를 연결하는 간선은 (A,B)와 같이 정점의 쌍으로 표현한다.

     (A,B) == (B,A)

   - 방향 그래프 (Directed Graph)

     간선에 방향성이 존재하는 그래프

     A→B로만 갈 수 있는 간선은 <A,B>로 표시한다.

     <A,B> ≠ <B,A>

2. 가중치 그래프

   간선에 비용이나 가중치가 할당된 그래프.

   네트워크(Network)라고도 한다

3. 연결 그래프 vs 비연결 그래프

   - 연결 그래프 (Connected Graph)

     무방향 그래프에 있는 모든 정점쌍에 대해서 항상 경로가 존재하는 경우

     예) 트리(사이클을 가지지 않는 연결 그래프)

   - 비연결 그래프 (Disconnected Graph)

     무방향 그래프에서 특정 정점쌍 사이에 경로가 존재하지 않는 경우

4. 사이클 vs 비순환 그래프

   - 사이클

     단순 경로의 시작 정점과 종료 정점이 동일한 경우

     (단순 경로: 경로 중에서 반복되는 정점이 없는 경우)

   - 비순환 그래프

     사이클이 없는 그래프

5. 완전 그래프

   그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프

   무방향 완전 그래프 ⇒ 정점 수 n이면 간선의 수는 n(n-1)/2

### 구현 2가지

1. **인접 리스트 (Adjacency List)**

   인접 리스트로 그래프를 표현하는 것이 가장 일반적인 방법이다.

   모든 정점을 인접 리스트에 저장한다. 즉, 각각의 정점에 인접한 정점들을 리스트로 표시한 것이다.

2. **인접 행렬 (Adjacency Matrix)**

   인접 행렬은 NxN Boolean Matrix로써 `matrix[i][j]`가 `true`라면 i→j로의 간선이 있다는 뜻이다.

   - 정수 행렬을 사용할 수도 있다,

   - 인접 리스트를 사용한 그래프 알고리즘들 또한 인접 행렬에서도 사용이 가능하다.

     하지만 인접 행렬은 조금 효율성이 떨어진다.

     인접 리스트는 어떤 노드에 인접한 노드들을 쉽게 찾을 수 있지만, 인접 행렬에서는 인접한 노드를 찾기 위해서는 모든 노드를 전부 순회해야 한다.

:heavy_plus_sign:**선택 방법**

- 인접 리스트

  그래프 내에 적은 숫자의 간선만을 가지는 *희소 그래프(Sparse Graph)* 의 경우.

  **장점**

  - 어떤 노드에 인접한 노드들을 쉽게 찾을 수 있다.
  - 그래프에 존재하는 모든 간선의 수는 O(N+E)안에 알 수 있다.

  **단점**

  - 정점 i의 리스트에 있는 노드의 수 즉, 정점 차수 만큼의 시간이 필요하다.

- 인접 행렬

  그래프에 간선이 많이 존재하는 *밀집 그래프(Dense Graph)* 의 경우

  **장점**

  - 두 정점을 연결하는 간선의 존재 여부를 O(1) 안에 알 수 있다.
  - 정점의 차수는 O(N) 안에 알 수 있다.

  **단점**

  - 어떤 노드에 인접한 노드를 찾기 위해서는 모든 노드를 전부 순회해야 한다.
  - 그래프에 존재하는 모든 간선의 수는 O(N^2)안에 알 수 있다.

### 탐색

일반적인 방법 2가지

1. **깊이 우선 탐색 (DFS, Depth First Search)**

   임의의 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법

   - 모든 노드를 방문하고자 하는 경우 이 방법을 선택한다.
   - 너비 우선 탐색보다 좀 더 간단하다.

2. **너비 우선 탐색 (BFS, Breadth First Search)**

   임의의 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법

   - 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 선택한다.

</br>

## Tree

노드로 이루어진 자료구조

- 트리는 하나의 루트 노드를 갖는다.
- 루트 노드는 0개 이상의 자식 노드를 가지고 있다.
- 그 자식 노드 또한 0개 이상의 자식 노드를 가지고 있고, 이는 반복적으로 정의된다.

### 특징

- 트리에는 사이클이 존재할 수 없다.

- 노드들은 특정 순서로 나열될 수도 있고, 그럴 수 없을 수도 있다.

- 비선형 자료구조로, 계층적 관계를 표현한다. (계층모델이다.)

- **그래프의 한 종류**이다.

  **사이클이 없는 하나의 연결 그래프**

  또는 **DAG(Directed Acyclic Graph, 방향성이 있는 비순환 그래프)의 한 종류**

- 노드가 N개인 트리는 항상 N-1개의 간선을 가진다.
- 루트에서 어떤 노드로 가는 경로는 유일하다.
  - 임의의 두 노드 간의 경로도 유일하다.
- 한 개의 루트 노드만이 존재하며, 모든 자식 노드는 한 개의 부모 노드만을 가진다.
- 순회는 Pre-order, In-order, Post-order로 이루어진다.
- 이진 트리, 이진 탐색 트리, 균형 트리(AVL트리, red-black 트리), 이진힙(최대힙, 최소힙)등이 있다.

### 종류

1. 이진 트리 (Binary Tree)

   각 노드가 최대 두 개의 자식을 갖는 트리.

   모든 트리가 이진 트리는 아니다.

   **이진 트리 순회**

   - 중위 순회(in-order)

     Left → Root → Right

   - 전위 순회(pre-order)

     Root → Left → Right

   - 후위 순회(post-order)

     Left → Right → Root

2. 이진 탐색 트리 (Binary Search Tree)

   모든 노드가 다음과 같은 특정 순서를 따르는 속성이 있는 이진 트리

   모든 왼쪽 자식들 ≤ n < 모든 오른쪽 자식들 (모든 노드 n에 대해서 반드시 참)

3. 균형 트리

   O(logN) 시간에 insert와 find를 할 수 있을 정도로 균형이 잘 잡혀있는 경우

   예) Red-Black Tree, AVL 트리

4. 전 이진 트리 vs 완전 이진 트리 vs 포화 이진 트리

   <img src="https://user-images.githubusercontent.com/33208360/116958381-5e988f00-acd5-11eb-95e3-a6a4ae9adb43.png" alt="image" style="zoom:67%;" />

   - 전 이진 트리 (Full Binary Tree 또는 Strictly Binary Tree)

     모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리

   - 완전 이진 트리 (Complete Binary Tree)

     트리의 모든 높이에서 노드가 꽉 차있는 이진 트리. 즉, 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있다.

     - 마지막 레벨은 꽉 차 있지 않아도 되지만, 노드가 왼쪽에서 오른쪽으로 채워져야 한다.
     - 배열을 사용해 효율적으로 표현이 가능하다.

   - 포화 이진 트리 (Perfect Binary Tree)

     전 이진 트리이면서 완전 이진 트리인 경우

     모든 말단 노드는 같은 높이에 있어야 하며, 마지막 단계에서 노드의 개수가 최대가 되어야 한다.

     모든 내부 노드가 두 개의 자식 노드를 가진다.

     모든 말단 노드가 동일한 깊이 또는 레벨을 갖는다.

     노드의 개수가 정확히 (2^k-1)개여야 한다. (k: 트리의 높이)

5. 이진 힙 (최소 힙, 최대 힙)

   - 최소힙 (Min Heap)

     트리의 마지막 단계에서 오른쪽 부분을 뺀 나머지 부분이 가득 채워져 있는 완전 이진 트리이며, 각 노드의 원소가 자식들의 원소보다 작다.

     즉, `부모 노드 ≥ 자식노드`인 완전 이진 트리

     가장 큰 값은 루트 노드이다.

     N개가 힙에 있으면 높이는 log(N)이다.

   - 최대힙 (Max Heap)

     원소가 내림차순으로 정렬되어 있다는 점만 최소힙과 다르다.

     각 노드의 원소가 자식들의 원소보다 크다.

     `부모 노드 <= 자식노드`인 완전 이진 트리

6. 트라이 (Trie)

   n-차 트리의 변종

   각 노드에 문자를 저장하는 자료구조

   ⇒ 따라서 트리를 아래쪽으로 순회하면 단어 하나가 나온다.

   접두사를 빠르게 찾아보기 위한 흔한 방식으로, 모든 언어를 트라이에 저장해 놓는 방식이 있다.

   유효한 단어 집합을 이용하는 많은 문제들은 트라이를 통해 최적화할 수 있다.

### 구현 방법

기본적으로 트리는 그래프의 한 종류이므로 그래프의 구현 방법으로 구현할 수 있다.

1. 인접 배열 이용
2. 인접 리스트 이용

</br>

## Graph vs Tree

<img src="https://user-images.githubusercontent.com/33208360/116958586-1cbc1880-acd6-11eb-9813-4757f03c0528.png" alt="image" style="zoom:67%;" />

</br>

## Heap

- 완전 이진 트리의 일종으로, 우선 순위 큐를 위해 만들어진 자료 구조이다.

- 여러 개의 값들 중 최댓값이나 최솟값을 빠르게 찾아내도록 만들어진 자료구조이다.

- 힙은 일종의 반정렬 상태(느슨한 정렬 상태)를 유지한다.

  ⇒ 큰 값이 상위 레벨에 있고, 작은 값이 하위 레벨에 있다는 정도

- 중복된 값을 허용한다. (이진 탐색 트리에서는 중복된 값을 허용하지 않는다.)

### 종류

- **최대 힙**

  부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리

- **최소 힙**

  부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리

### 구현

힙을 저장하는 표준적인 자료 구조는 **배열**이다.

⇒ 구현을 쉽게 하기 위해 배열의 0번 인덱스는 사용하지 않는다.

- 부모 노드와 자식노드의 관계
  - 왼쪽 자식의 인덱스 = (부모 인덱스) * 2
  - 오른쪽 자식의 인덱스 = (부모 인덱스) * 2 + 1
  - 부모 인덱스 = (자식 인덱스) / 2

**삽입**

1. 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입한다.
2. 새로운 노드를 부모 노드들과 교환해서 힙의 성질을 만족시킨다.

**삭제**

1. 최대 힙에서 최댓값을 루트 노드이므로 루트 노드가 삭제된다. (최소 힙에서 최솟값은 루트)
2. 삭제된 루트 노드에는 힙의 마지막 노드를 가져온다.
3. 힙을 재구성한다.

</br>

## 균형 트리

일반적인 이진 검색 트리에서는 트리 구조가 한 쪽으로 치우쳐지는 경우가 발생할 수 있다. 이진 검색 트리의 평균 검색 속도는 O(logN)이지만, 한 쪽으로 치우쳐진 경우에는 검색 속도가 O(N)까지 저하될 수 있다.

⇒ 이를 방지하기 위해 리벨런싱 작업을 수행하는 자료 구조로 AVL Tree, B-Tree, Red Black Tree가 있다.

<br>

## AVL Tree

이진 탐색 트리이면서 동시에 균형을 유지하고 있다.

​	⇒ **BF(Balance Factor)**를 통해 균형을 맞춘다. BF값을 통한 균형은 rotation을 통해 이루어진다.

- 왼쪽 서브 트리의 높이에서 오른쪽 서브 트리의 높이를 뺀 값이 그 노드의 BF가 된다.

* 모든 노드의 왼쪽과 오른쪽 서브트리의 높이 차이가 1이하이다.

  ⇒ 이렇게 균형을 유지하고 있기 때문에 이진 검색 시의 효율성을 보장할 수 있다.

* 좌우 높이 차가 1보다 커지면 균형이 무너진 것.

  ⇒ 균형이 무너진 유형에는 4가지가 있다.

  <img src="https://user-images.githubusercontent.com/33208360/116958913-0a8eaa00-acd7-11eb-9644-9c16ecac634f.png" alt="image" style="zoom: 50%;" />

  * LL (Left-Left)

    왼쪽의 높이가 오른쪽의 높이보다 큰 것 (2이상)	⇒ 우회전 한 번

    <img src="https://user-images.githubusercontent.com/33208360/116959042-5f322500-acd7-11eb-8cf9-4a80494bbd5e.png" alt="image" style="zoom:50%;" />

  * RR (Right-Right)

    오른쪽의 높이가 왼쪽의 높이보다 큰 것 (2이상)	⇒ 좌회전 한 번

    <img src="https://user-images.githubusercontent.com/33208360/116959077-7bce5d00-acd7-11eb-94cf-06ea61c6e778.png" alt="image" style="zoom:50%;" />

  * LR (Left - Right)

    두 번째 노드를 좌회전 한 후, 전체 노드를 우회전한다.

    <img src="https://user-images.githubusercontent.com/33208360/116959117-930d4a80-acd7-11eb-88d9-95040c893ec2.png" alt="image" style="zoom:50%;" />

  * RL (Right-Left)

    두 번째 노드를 우회전 한 번 후, 전체 노드를 좌회전 한다.

    <img src="https://user-images.githubusercontent.com/33208360/116959141-a3252a00-acd7-11eb-9150-0b5a5a6c7a4a.png" alt="image" style="zoom:50%;" />

> https://velog.io/@soonbee/AVL-Tree%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90

<br>

## Red-Balck Tree

이진 탐색 트리이다.

<img src="https://user-images.githubusercontent.com/33208360/116959205-dbc50380-acd7-11eb-930d-d8c91f0454c7.png" alt="image" style="zoom:50%;" />

### 조건

(트리의 모든 노드는 레드 or 블랙)

1. 루트 노드는 무조건 블랙

2. 모든 리프노드는 블랙

3. **루트 노드에서 리프 노드까지 블랙의 갯수는 항상 같다. ⇒ 이 조건이 레드 블랙 트리의 균형을 책임진다.**

   위의 예시)

   리프 노드 6은 블랙 노드 1을

   리프 노드 22는 블랙 노드 25를

   리프 노드 27은 블랙 노드 25를

4. 레드 노드의 자식은 모두 블랙, 블랙 노드의 자식은 상관 없음

   ⇒ 레드는 중복될 수 없으니 반드시 레드와 레드 사이엔 하나의 블랙 노드를 끼게 되고, 이는 곧 레드 블랙 트리의 총 깊이가 된다.

### 동작

- 이진 탐색 트리이기 때문에 탐색, 삽입, 삭제 연산으로 동작한다.
- 탐색 연산은 변경할 필요가 없으나 삽입, 삭제 연산의 경우 균형을 맞춰주는 동작이 필요하다.

### 연산 - Restructuring, Recoloring

자신(Z)과 부모 노드(V)가 레드라면, (레드는 중복될 수 없으므로 연산으로 처리해주어야 함)

1. **삼촌 노드(W)가 블랙일 때 → Restructuring(Rotation)**

   <img src="https://user-images.githubusercontent.com/33208360/116959415-8e956180-acd8-11eb-9edf-a540e3e36d7d.png" alt="image" style="zoom:33%;" />

   1) 나(Z)와 부모(V), 부모의 부모를 오름차순으로 정렬한다.

   2) 무조건 가운데 있는 값을 부모로 만들고, 나머지 둘을 자식으로 만든다.

   3) 올라간 가운데 있는 값을 블랙으로 만들고 두 자식을 레드로 만든다.

2. **삼촌 노드(W)가 레드일 때 → Recoloring**

   <img src="https://user-images.githubusercontent.com/33208360/116959482-b7b5f200-acd8-11eb-8028-5ef77ef627c4.png" alt="image" style="zoom:33%;" />

   1) 삽입된 노드(Z)의 부모와 삼촌(W)을 블랙으로 하고, 부모의 부모를 레드로 만든다.

   2) 부모의 부모가 Root가 아니었을 시, 더블 레드가 다시 발생 가능

   ​	(이때 Root라면, "Root는 블랙"이라는 규칙에 위배되므로 다시 검정으로 변경한다.)