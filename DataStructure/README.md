# Data Structure

1. [Array vs LinkedList](#array-vs-linkedlist)

   * [Array (배열)](#array-배열)

   * [LinkedList](#linkedlist)

   * [Array와 LinkedList 차이점?](#array와-linkedlist-차이점)

   * [결론](#결론)

2. [ArrayList vs LinkedList](arraylist-vs-linkedlist)

   * [ArrayList](#arraylist)
   * [LinkedList](#linkedlist)
   * [데이터 검색, 삽입, 삭제 성능 비교](#데이터-검색-삽입-삭제-성능-비교)

3. [HashTable](#hashtable)

   * [HashTable(해시테이블)이란?](#hashtable해시테이블이란)
   * [Hash값이 충돌하는 경우](#hash값이-충돌하는-경우분리연결법-개방-주소법-resizing)
   * [해시테이블의 시간 복잡도](#해시테이블의-시간-복잡도)
   * [HashTable의 장점](#hashtable의-장점)
   * [HashTable의 단점](#hashtable의-단점)
   * [Java의 HashMap과 Hashtable의 차이](#java의-hashmap과-hashtable의-차이)

4. 

## Array vs LinkedList

### Array (배열)

- 논리적 저장 순서와 물리적 저장 순서가 일치한다.

- 인덱스로 해당 원소에 접근이 가능하다.

  ⇒ 인덱스만 알고 있다면 시간 복잡도 O(1)만에 해당 원소로 접근할 수 있다.

  ⇒ 즉, Random Access가 가능하다.

- 배열의 원소를 삭제할 경우, 삭제한 원소보다 큰 인덱스를 가지는 원소들을 옮겨줘야(Shift)하기 때문에 시간 복잡도 O(n)이 걸린다.

  삽입의 경우, 새로운 원소를 추가하고 모든 원소들의 인덱스를 1식 Shift 해줘야 하므로 시간 복잡도 O(n)이 걸린다.

  ⇒ 즉, 삭제 또는 삽입의 과정에서 해당 원소에 접근하여 작업을 완료한 뒤 Shift를 해줘야 하는 cost가 발생하기 때문에 O(n)의 시간복잡도를 갖는다.

- 제한적인 크기를 갖는다.

### LinkedList

- 자료의 주소 값으로 노드를 이용해 서로 연결되어 있는 구조를 갖는다.

- 삽입과 삭제의 경우, LinkedList가 Array보다 속도가 빠르다고 하지만 엄밀히 말하면 경우에 따라 다르다.

  ⇒ LinkedList 역시 삽입과 삭제를 위해서 해당 노드를 찾아가는 동안 O(n)의 시간 복잡도를 갖는다.

  ⇒ 만약, 중간 삽입이 없다면, 즉 맨 앞과 맨 뒤에 삽입한다면 시간 복잡도 O(1)

  ⇒ 삭제도 마찬가지. 중간 삭제가 없고 맨 앞과 맨 뒤에서만 삭제한다면 시간 복잡도 O(1)

- 원하는 값을 찾기 위해서 최소 한 번은 리스트를 순회해야 하므로 O(n)의 시간 복잡도를 갖는다.

- 트리의 근간이 되는 자료구조이다.

### Array와 LinkedList 차이점?

1. 데이터 접근 속도

   - Array는 인덱스를 사용해 빠르게 원소에 접근할 수 있다. Random Access를 지원한다. 시간 복잡도 O(1)로 빠르게 찾을 수 있다.
   - LinkedList는 순차 접근 방식을 사용한다. 특정 원소에 접근하기 위해서는 처음부터 원소에 도달할 때까지 순차적으로 검색하면서 찾는다. 시간 복잡도 O(N)

2. 데이터의 삽입 속도

   - Array의 경우 데이터를 중간이나 맨 앞에 삽입할 경우, 그 이후의 데이터를 한 칸 씩 미뤄야 하는 추가 과정과 시간이 소요된다. 데이터가 많을수록 비효율적이다.

     ⇒ 그렇기 때문에 LinkedList가 필요

   - LinkedList는 어느 곳에 삽입하던지 O(N)의 시간 복잡도를 갖는다. (중간 삽입이 없다면 O(1)의 시간 복잡도를 갖는다.)

     ⇒ 삽입할 위치를 찾고(O(N)), 삽입 연산을 진행하기 때문에 O(N)의 시간 복잡도를 갖는다. 그럼에도 Array보다 빠른 성능을 보인다.

   - 또, Array의 경우 데이터 삽입 시 모든 공간이 다 차버렸다면 새로운 메모리 공간을 할당 받지만, LinkedList는 그럴 필요가 없다. 추가할 때마다 동적으로 할당한다.

3. 데이터의 삭제 속도

   - Array는 데이터의 삭제의 경우 그 위치의 데이터를 삭제한 후, 전체적으로 Shift해줘야 한다. (O(N))
   - LinkedList의 경우 삭제할 원소를 찾기 위해서 O(N)의 시간 복잡도를 갖고 삭제를 한다. 결국 O(N)의 시간 복잡도를 갖는다. 하지만 Array보다 빠르게 삭제 연산을 수행한다.

4. 메모리 할당

   - Array에서 메모리는 Array가 선언되지 마자 Compile time에 할당되어 진다. 이것을 정적 메모리 할당이라고 한다.
   - LinkedList에서 메모리는 새로운 node가 추가될 때 Runtime에 할당되어진다. 이것은 동적 메모리 할당이라고 한다.

5. Size

   - Array의 size는 반드시 선언 시점에 지정되어 있어야 한다.
   - LinkedList의 size는 다양할 수 있다. node들이 추가될 때 Runtime시점에서 LinkedList의 size가 커질 수 있기 때문이다.

### 결론

- 삽입과 삭제가 빈번하다면 LinkedList를 사용하는 것이 더 좋다.
- 데이터의 접근하는 것이 중요하다면 Array를 사용하는 것이 더 좋다.

</br>

## ArrayList vs LinkedList

### ArrayList

- 내부적으로 데이터를 배열에서 관리하며, 데이터의 추가, 삭제를 위해서 임시 배열을 생성해 데이터를 복사하는 방법을 사용한다.
- 대량의 자료를 추가/삭제 하는 경우 그만큼 데이터의 복사가 많이 일어나게 되어 성능 저하가 발생한다.
- 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 존재해야 한다.
- 인덱스를 가지고 있어 한 번에 참조가 가능해 데이터 검색에 유리하다.

원소에 대해 빠르게 접근할 수 있을 뿐만 아니라, 원소들이 메모리에 연속으로 배치해 있어 CPU 캐시 효율도 더욱 높다.

### LinkedList

- 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있으면 된다.
- ArrayList와 달리 데이터의 추가/삭제 시, 불필요한 데이터의 복사가 없어 데이터의 추가, 삭제 시에 유리하다.
- 반면, 데이터 검색 시에는 처음부터 노드를 순회하기 때문에 성능상 불리하다.

### 데이터 검색, 삽입, 삭제 성능 비교

1. 검색
   - ArrayList : 인덱스 기반이기 때문에 O(1)의 시간 복잡도를 갖는다.
   - LinkedList : 검색 시 모든 요소를 순차적으로 탐색해야 하기 때문에 O(N)의 시간 복잡도를 갖는다.
2. 삽입, 삭제
   - ArrayList : 삽입, 삭제 이후 다른 데이터를 복사해야 하기 때문에 O(N)의 시간 복잡도를 갖는다. (가지고 있던 용량이 꽉 찼을 때, 용량이 기존의 1.5배를 늘린 새로운 배열에 기존 배열을 copy하는 것)
   - LinekdList : 이전 노드와 다음 노드를 참조하는 상태만 변경하면 되기 때문에 삽입, 삭제 시에 O(1)의 시간 복잡도를 갖는다.

</br>

## HashTable

### HashTable(해시테이블)이란?

(Key, Value)로 데이터를 저장하는 자료 구조

- 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문에 빠르게 데이터를 검색할 수 있는 자료 구조이다.

- 각각의 Key값에 해시 함수를 적용해 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색하게 된다.

  ⇒ 여기서 실제 값이 저장되는 장소를 버킷 또는 슬롯 이라고 한다.

- 이러한 구조로 데이터를 저장하면 Key값으로 데이터를 찾을 때, 해시 함수를 1번만 수행하면 되므로 매우 빠르게 데이터를 저장/삭제/조회 할 수 있다.

  ⇒ 해시 테이블의 평균 시간 복잡도는 O(1)이다.

**:heavy_plus_sign: Hash 함수 (해시 함수)**

해시 함수에서 가장 중요한 것은 고유한 인덱스 값을 설정하는 것이다. 대표적인 해시 함수로는 아래의 3가지가 있다.

1. Division Method

   나눗셈을 이용하는 방법으로 입력값을 테이블의 크기로 나누어 계산한다.

   (주소 = 입력값 % 테이블의 크기)

   테이블의 크기를 소수로 정하고 2의 제곱수와 먼 값을 사용해야 효과가 좋다고 알려져 있다.

2. Digit Folding

   각 Key의 문자열을 ASCII코드로 바꾸고 값을 합한 데이터를 테이블 내의 주소로 사용하는 방법이다.

3. Multiplication Method

   숫자로 된 Key값 K와 0과 1사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 다음과 같은 계산을 해준다.

   h(k) = (kAmod1)*m

4. Universal Hashing

   다수의 해시 함수를 만들어 집합 H에 넣어 두고, 무작위로 해시 함수를 선택해 해시 값을 만드는 기법이다.

### Hash값이 충돌하는 경우(분리연결법, 개방 주소법, Resizing)

해시 테이블에서는 충돌에 의한 문제를 **분리 연결법**과 **개방 주소법** 크게 2가지로 해결하고 있다.

1. **분리 연결법 (Separate Chaining)**

   동일한 버킷의 데이터에 대해 자료구조를 활용해 추가 메모리를 사용하여 다음 데이터의 주소를 저장하는 것이다.

   (⇒ 동일한 버킷으로 접근한다면, 데이터들을 연결해서 관리해준다.)

   (➕ 실제로 Java8의 Hashtable은 Self-Balancing Binary Search Tree 자료구조를 사용해 Chaning방식을 구현하였다. JDK 내부에서 사용하는 충돌 처리 방식)

   - 이러한 Chaining 방식은 해시 테이블의 확장이 필요 없고, 간단하게 구현이 가능하며, 손쉽게 삭제할 수 있다는 장점이 있다.
   - LinkedList 구조를 사용하기 때문에 추가 데이터 수 제약이 적은 편이다. 하지만, 데이터의 수가 많아지면 동일한 버킷에 Chaining되는 데이터가 많아지며 그에 따라 캐시의 효율성이 감소한다는 단점이 있다.

2. **개방 주소법 (Open Addressing)**

   추가적인 메모리를 사용하는 Chaining 방식과 다르게 비어있는 해시 테이블의 공간을 활용하는 방법이다.

   Separating Chaining 방식에 비해 적은 메모리를 사용한다.

   Open Addressing을 구현하기 위한 대표적인 방법으로는 3가지 방식이 존재한다.

   1. Linear Probing(선형 탐사)

      현재의 버킷 index로부터 고정폭만큼씩 이동하여 차례대로 검색해 비어있는 버킷에 데이터를 저장한다.

   2. Queadratic Probing(제곱 탐사)

      해시의 저장 순서 폭을 제곱으로 저장하는 방식이다.

      예를 들어, 처음 충돌이 발생한 경우에는 1만큼 이동하고, 그 다음 계속 충돌이 발생하면 2^2, 3^2 칸씩 옮기는 방식이다.

   3. Double Hashing Probing(이중 해싱)

      해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애버리는 방식이다.

      해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 하게 된다.

   Open Addressing에서 데이터를 삭제하면 삭제된 공간은 Dummy Space로 활용되는데, 그렇기 때문에 HashTable을 재정리해주는 작업이 필요하다고 한다.

3. **Resizing**

   저장 공간이 일정 수준 채워지면 Separating Chaining의 경우 성능 향상을 위해 Open Addressing의 경우 배열 크기 확장을 위해 Resizing한다.

   보통 2배로 확장하며, 확장 임계점은 현재 데이터 개수가 Hash bucket 개수의 75%가 될 때이다.

### 해시테이블의 시간 복잡도

각각의 Key값은 해시 함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로, 평균 O(1)의 시간 복잡도로 데이터를 조회할 수 있다.

하지만, 데이터의 충돌이 발생한 경우 Chaining에 연결된 리스트들까지 검색을 해야하므로 O(N)까지 시간 복잡도가 증가할 수 있다.

충돌을 방지하는 방법들은 데이터의 규칙성(클러스터링)을 방지하기 위한 방식이지만, 공간을 많이 사용한다는 치명적인 단점이 있다.

만약, 테이블이 꽉 차있는 경우라면 테이블을 확장해주어야 하는데, 이는 매우 심각한 성능 저하를 불러오기 때문에 가급적이면 확장을 하지 않도록 테이블을 설계해주어야 한다.

( ⇒ 통계적으로, 해시 테이블의 공간 사용률이 70~80% 정도가 되면 해시의 충돌이 빈번하게 발생하여 성능이 저하되기 시작한다고 한다.)

➕ 또한 해시 테이블에서 자주 사용하게 되는 데이터를 Cache에 적용하면 효율을 높일 수 있다. 자주 hit하게 되는 데이터를 캐시에서 바로 찾음으로써 해시 테이블의 성능을 향상시킬 수 있다.

### HashTable의 장점

- 적은 리소스로 많은 데이터를 효율적으로 관리 가능하다.

- 배열의 인덱스를 사용하기 때문에 빠른 검색, 삽입, 삭제 ⇒ O(1)

  (Hashtable의 경우 인덱스는 데이터의 고유 위치이기 때문에 삽입, 삭제 시 다른 데이터를 이동할 필요가 없어 삽입, 삭제도 빠른 속도로 가능하다.)

- Key와 Hash에 연관성이 없어 보안에 유리하다.

- 데이터 캐싱에 많이 사용된다.

  get, put기능에 캐시 로직 추가 시, 자주 hit하는 데이터 바로 검색 가능

- 중복 제거에 유용하다.

### HashTable 단점

- 충돌 발생 가능성
- 공간 복잡도 증가
- 순서 무시
- 해시 함수에 의존

### Java의 HashMap과 Hashtable의 차이

그 차이는 동기화 지원 여부에 있다.

해시테이블의 put에는 `synchronized` 키워드가 붙어있는데, 이것은 병렬 프로그래밍을 할 때 동기화를 지원해준다는 것을 의미한다. 이것은 해당 함수를 처리하는 시간이 조금 지연됨을 의미한다.

그렇기 때문에, 병렬 처리를 하면서 자원의 동기화를 고려해야 하는 상황이라면 `Hashtable`을 사용해야 하며, 병렬 처리를 하지 않거나 자원의 동기화를 고려하지 않는 상황이라면 `HashMap`을 사용하면 된다.