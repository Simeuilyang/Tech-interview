# Java

[JVM](#jvm)

1. [JVM의 기능은?](#jvm의-기능은)

2. [자바 컴파일 과정을 설명해보세요.](#자바-컴파일-과정(프로그램실행-과정)을-설명해보세요)

3. [JVM 메모리 영역을 설명해보세요.](#jvm-메모리-영역을-설명해보세요)

[Garbage Collection](#garbage-collection)

## JVM

### JVM의 기능은?
JVM은 Java Virtual Machine, 자바 가상 머신으로, Stack기반의 가상머신입니다. 

주요 기능으로는 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 AOI와 함께 실행하는 것입니다. 또, 자바 프로그램이 어느 기기나 운영체제 상에서도 독립적으로 실행될 수 있도록 하고, 프로그램 메모리를 관리하고 최적화합니다.

### 자바 컴파일 과정(프로그램실행 과정)을 설명해보세요.
1. 자바 소스코드(.java)를 자바 컴파일러가 읽어들여 자바 바이트 코드(.class)로 변환시킵니다.
2. 컴파일된 바이트 코드를 JVM 클래스 로더(Class Loader)에게 전달합니다.
3. 클래스 로더는 동적 로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data Area), 즉 JVM의 메모리에 올립니다.
4. 실행 엔진(Excution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행합니다. 이 때 실행 엔진은 두 가지 방식으로 변경합니다.

    1. 인터프리터 : 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행합니다. 전체적인 실행 속도가 느리다는 단점이 있습니다.
    2. JIT 컴파일러(Just in time compiler) : 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이 후에는 해당 메서드를 더이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식입니다. 전체적인 실행 속도는 인터프리팅 방식보다 빠릅니다.  

### JVM 메모리 영역을 설명해보세요.
Runtime Data Area로 프로그램을 수행하기 위해 OS에서 할당받은 메모리입니다. PC Register, JVM Stack영역, Native Method Stack, Method Area, Heap영역으로 구성되어 있습니다.

<img src="https://user-images.githubusercontent.com/33208360/116801888-10568500-ab49-11eb-9497-979053d8e60c.png" alt="image" style="zoom: 50%;" />

먼저, **PC Register**는 Thread가 생성될 때마다 생성되는 공간으로, Thread마다 하나씩 존재합니다. thres가 어떤 부분의 명령을 실행해야할 지에 대한 기록을 하는 부분으로 현재 수행 중인 JVM명령의 주소를 갖습니다.

두 번째로, **JVM Stack**영역은 프로그램 실행과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역입니다. 각종 형태의 변수나 임시 데이터, 스레드나 메소드의 정보를 저장합니다.

(:heavy_plus_sign: 특징: 메소드를 호출할 때마다 그 메소드만을 위한 공간으로 각각의 Stack 프레임이 생성됩니다. 메소드 수행이 끝나면 프레임별로 삭제됩니다.

또, 호출된 메소드의 매개변수, 메소드 안에서 사용되는 값인 지역변수, 리턴 값 및 연산시 일어나는 값 등을 임시로 저장합니다. ) 

세 번째로, **Native Method Stack**은 자바 프로그램이 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역입니다. Java가 아닌 다른 언어로 작성된 코드를 위한 공간으로, 일반 프로그램처럼 커널이 스택을 잡아 독자적으로 프로그램을 실행시키는 영역입니다.

네 번째로, **Method Area**(=Class Area = Stack Area)는 클래스 정보를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간입니다.

마지막으로, **Heap**영역은 객체를 저장하는 가상 메로리 공간으로, `new` 연산자로 생성된 객체와 배열을 저장합니다. (Class Area영역에 올라온 클래스들만 객체로 생성할 수 있다.)

Heap은 세 부분으로 나뉘는데, Permanent 영역, New/Young영역, Old영역으로 나뉩니다.

1. Permanent 영역은 생성된 객체 정보의 주소값이 저장되는 공간입니다. Class Loader에 의해 로드되는 class, Method 등에 대한 메타정보가 저장되는 영역이고, JVM에 의해 사용됩니다. (+ 또, Reflection을 사용하여 동적으로 클래스가 로딩되는 경우에 사용됩니다. 내부적으로 Reflection기능을 자주 사용하는 Spring프레임워크를 이용할 경우 이 영역에 대한 고려가 필요.)
2. New/Young 영역은 Eden과 Survivor 0/1공간이 있는데, Eden은 객체들이 최초로 생성되는 공간이며, Survivor0/1 은 Eden에서 참조되는 객체들이 저장되는 공간입니다.
3. Old영역은 New Area에서 일정 시간 참조되고 있는, 살아남은 객체들이 저장되는 공간입니다.

(:heavy_plus_sign: 인스턴스는 소멸 방법과 소멸 시점이 자역변수와 다르기 때문에 Heap이라는 별도의 영역에 할당됩니다. )

## Garbage Collection

